import { logger } from '../utils/logger.js';
import { eventsStream } from '../streaming/events.stream.js';

class WorkflowEngine {
  constructor() {
    this.executions = new Map();
  }
  
  async executeWorkflow(workflowInput) {
    const { workflowId, executionId, input, autoGenerated } = workflowInput;
    
    // Ensure executionId is never undefined
    const safeExecutionId = executionId || `exec_${Date.now()}`;
    
    logger.info(`Starting workflow execution: ${safeExecutionId} (${autoGenerated ? 'auto-generated' : 'manual'})`);
    
    // Create execution instance
    const execution = {
      id: safeExecutionId,
      workflowId,
      status: 'running',
      input,
      steps: new Map(),
      graph: this.createInitialGraph(workflowId, input, autoGenerated),
      startTime: new Date().toISOString(),
      autoGenerated
    };
    
    this.executions.set(safeExecutionId, execution);
    
    // Execute workflow steps
    try {
      await this.executeSteps(execution);
      execution.status = 'completed';
      execution.endTime = new Date().toISOString();
    } catch (error) {
      execution.status = 'failed';
      execution.endTime = new Date().toISOString();
      logger.error(`Workflow execution failed: ${safeExecutionId}`, error);
    }
    
    return execution;
  }
  
  createInitialGraph(workflowId, input, autoGenerated) {
    // API-style workflows get different graph structure
    if (workflowId.startsWith('api::')) {
      const apiType = workflowId.replace('api::', '');
      return {
        nodes: [
          { id: 'entry', type: 'entry', status: 'completed', x: 400, y: 100 },
          { id: 'validate', type: 'workflow', status: 'pending', x: 400, y: 220 },
          { id: 'process', type: 'workflow', status: 'pending', x: 400, y: 340 }
        ],
        edges: [
          { from: 'entry', to: 'validate' },
          { from: 'validate', to: 'process' }
        ],
        metadata: {
          apiType,
          autoGenerated: true
        }
      };
    }
    
    // File processing workflow
    if (workflowId === 'wf_file_processing') {
      return {
        nodes: [
          { id: 'start', type: 'entry', status: 'completed', x: 400, y: 100 },
          { id: 'validate', type: 'workflow', status: 'pending', x: 400, y: 220 },
          { id: 'process', type: 'workflow', status: 'pending', x: 400, y: 340 }
        ],
        edges: [
          { from: 'start', to: 'validate' },
          { from: 'validate', to: 'process' }
        ]
      };
    }
    
    // Default graph
    return {
      nodes: [
        { id: 'start', type: 'entry', status: 'completed', x: 400, y: 100 },
        { id: 'validate', type: 'workflow', status: 'pending', x: 400, y: 220 },
        { id: 'process', type: 'workflow', status: 'pending', x: 400, y: 340 }
      ],
      edges: [
        { from: 'start', to: 'validate' },
        { from: 'validate', to: 'process' }
      ]
    };
  }
  
  async executeSteps(execution) {
    const isApiWorkflow = execution.workflowId.startsWith('api::');
    const stepOrder = isApiWorkflow ? ['entry', 'validate', 'process'] : ['start', 'validate', 'process'];
    let currentInput = execution.input;
    let previousStepFailed = false;
    
    for (const stepId of stepOrder) {
      if (stepId === 'start' || stepId === 'entry') {
        // Entry step passes normalized input through
        const stepExecution = {
          id: stepId,
          name: stepId,
          status: 'completed',
          input: currentInput,
          output: currentInput,
          startTime: new Date().toISOString(),
          endTime: new Date().toISOString()
        };
        
        execution.steps.set(stepId, stepExecution);
        continue;
      }
      
      // Skip downstream steps if previous step failed
      if (previousStepFailed) {
        const skipReason = stepId === 'process' ? 'validate Step failed' : 'Previous step failed';
        
        const stepExecution = {
          id: stepId,
          name: stepId,
          status: 'skipped',
          input: currentInput,
          error: skipReason,
          startTime: new Date().toISOString(),
          endTime: new Date().toISOString()
        };
        
        execution.steps.set(stepId, stepExecution);
        this.updateStepStatus(execution, stepId, 'skipped');
        
        eventsStream.emit('step:skipped', { 
          stepId, 
          status: 'skipped',
          reason: skipReason,
          timestamp: new Date().toISOString() 
        });
        
        continue;
      }
      
      // Update graph to show step as running
      this.updateStepStatus(execution, stepId, 'running');
      eventsStream.emit('graph:update', { graph: execution.graph });
      
      const stepExecution = {
        id: stepId,
        name: stepId,
        status: 'running',
        input: currentInput,
        startTime: new Date().toISOString()
      };
      
      execution.steps.set(stepId, stepExecution);
      
      try {
        // Execute step with contract validation
        const output = await this.executeStep(stepId, currentInput, isApiWorkflow);
        
        stepExecution.status = 'completed';
        stepExecution.output = output;
        stepExecution.endTime = new Date().toISOString();
        
        // Update graph
        this.updateStepStatus(execution, stepId, 'completed');
        
        // Emit structured execution event for data lineage
        eventsStream.emit('step:complete', { 
          stepId, 
          status: 'completed',
          input: currentInput,
          output,
          usedFields: this.extractUsedFields(stepId, currentInput, output),
          executionTime: new Date(stepExecution.endTime) - new Date(stepExecution.startTime),
          timestamp: new Date().toISOString() 
        });
        
        currentInput = output;
        
        // Add delay for demo purposes
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (error) {
        stepExecution.status = 'failed';
        stepExecution.error = error instanceof Error ? error.message : 'Unknown error';
        stepExecution.endTime = new Date().toISOString();
        
        this.updateStepStatus(execution, stepId, 'failed');
        
        eventsStream.emit('step:failed', { 
          stepId, 
          status: 'failed',
          error: stepExecution.error,
          timestamp: new Date().toISOString() 
        });
        
        // Mark that a step failed so downstream steps will be skipped
        previousStepFailed = true;
        
        // Continue to next iteration to skip remaining steps
        continue;
      }
      
      eventsStream.emit('graph:update', { graph: execution.graph });
    }
  }
  
  markDownstreamStepsBlocked(execution, failedStepId) {
    const stepOrder = execution.workflowId.startsWith('api::') ? 
      ['entry', 'validate', 'process'] : 
      ['start', 'validate', 'process'];
    
    const failedIndex = stepOrder.indexOf(failedStepId);
    if (failedIndex >= 0) {
      for (let i = failedIndex + 1; i < stepOrder.length; i++) {
        this.updateStepStatus(execution, stepOrder[i], 'blocked');
      }
    }
  }
  
  async executeStep(stepId, input, isApiWorkflow) {
    logger.info(`Executing step: ${stepId} (API: ${isApiWorkflow})`);
    
    // Validate input contracts
    this.validateStepInput(stepId, input, isApiWorkflow);
    
    if (isApiWorkflow) {
      switch (stepId) {
        case 'validate':
          return this.validateApiStep(input);
        case 'process':
          return this.processApiStep(input);
        default:
          throw new Error(`Unknown API step: ${stepId}`);
      }
    } else {
      switch (stepId) {
        case 'validate':
          return this.validateStep(input);
        case 'process':
          return this.processStep(input);
        default:
          throw new Error(`Unknown step: ${stepId}`);
      }
    }
  }
  
  validateStepInput(stepId, input, isApiWorkflow) {
    if (!input || typeof input !== 'object') {
      throw new Error(`${stepId} Step requires valid input object`);
    }
    
    if (isApiWorkflow) {
      switch (stepId) {
        case 'validate':
          // Use the same strict validation as main index.js
          this.validateFileUploadInput(input);
          break;
        case 'process':
          if (!input.validation || input.validation.status !== 'passed') {
            throw new Error('validate Step failed');
          }
          break;
      }
    } else {
      switch (stepId) {
        case 'validate':
          if (!input.fileId || !input.checksum) {
            throw new Error('validate Step requires fileId and checksum');
          }
          break;
        case 'process':
          if (!input.validated) {
            throw new Error('process Step requires validated input');
          }
          break;
      }
    }
  }
  
  validateFileUploadInput(input) {
    const errors = [];
    
    // Field-level validation with specific error messages
    if (!input.fileId) {
      errors.push('fileId is required');
    } else if (typeof input.fileId !== 'string' || input.fileId.trim() === '') {
      errors.push('fileId must be non-empty string');
    }
    
    if (!input.fileName) {
      errors.push('fileName is required');
    } else if (typeof input.fileName !== 'string' || input.fileName.trim() === '') {
      errors.push('fileName must be non-empty string');
    }
    
    if (input.fileSizeMB === undefined || input.fileSizeMB === null) {
      errors.push('fileSizeMB is required');
    } else if (typeof input.fileSizeMB !== 'number') {
      errors.push('fileSizeMB must be a number');
    } else if (input.fileSizeMB <= 0) {
      errors.push('fileSizeMB must be > 0');
    }
    
    const supportedTypes = ['image/png', 'image/jpeg', 'image/gif'];
    if (!input.fileType) {
      errors.push('fileType is required');
    } else if (!supportedTypes.includes(input.fileType)) {
      errors.push('Unsupported fileType');
    }
    
    if (!input.uploadedBy) {
      errors.push('uploadedBy is required');
    } else if (typeof input.uploadedBy !== 'string' || input.uploadedBy.trim() === '') {
      errors.push('uploadedBy must be non-empty string');
    }
    
    if (input.checksum === undefined || input.checksum === null) {
      errors.push('checksum is required');
    } else if (typeof input.checksum !== 'string') {
      errors.push('checksum must be a string');
    }
    
    // If multiple errors, report all of them
    if (errors.length > 0) {
      throw new Error(errors.join(', '));
    }
    
    return true;
  }
  
  async validateApiStep(input) {
    // Use strict validation - this will throw if validation fails
    this.validateFileUploadInput(input);
    
    // Only reach here if validation passes
    return {
      ...input,
      validated: true,
      validatedAt: new Date().toISOString(),
      validationResult: {
        fileValid: input.fileSizeMB > 0 && input.fileSizeMB < 100,
        userValid: input.uploadedBy !== 'anonymous',
        mimeTypeValid: input.fileType.includes('/')
      }
    };
  }
  
  async processApiStep(input) {
    // Check if validation passed
    if (!input.validated) {
      throw new Error('validate Step failed');
    }
    
    // Process validated API input
    return {
      ...input,
      processed: true,
      processedAt: new Date().toISOString(),
      fileStatus: 'uploaded',
      fileUrl: `/files/${input.fileId}`,
      processingResult: {
        status: 'success',
        message: `File ${input.fileId} processed successfully`
      }
    };
  }
  
  async validateStep(input) {
    // Simulate validation logic for workflow format
    return {
      ...input,
      validated: true,
      validatedAt: new Date().toISOString()
    };
  }
  
  async processStep(input) {
    // Simulate processing logic for workflow format
    return {
      ...input,
      processed: true,
      processedAt: new Date().toISOString(),
      result: `Processed file ${input.fileId}`
    };
  }
  
  updateStepStatus(execution, stepId, status) {
    execution.graph.nodes = execution.graph.nodes.map(node =>
      node.id === stepId ? { ...node, status } : node
    );
  }
  
  extractUsedFields(stepId, input, output) {
    // Track which fields were read/validated/transformed
    const usedFields = [];
    
    if (stepId === 'validate') {
      // Validation step reads all required fields
      usedFields.push('fileId', 'fileName', 'fileSizeMB', 'fileType', 'uploadedBy', 'checksum');
    } else if (stepId === 'process') {
      // Process step uses validation results
      usedFields.push('validated', 'fileId', 'fileName');
    }
    
    return usedFields;
  }
  
  getExecution(executionId) {
    return this.executions.get(executionId);
  }
  
  getAllExecutions() {
    return Array.from(this.executions.values());
  }
  
  getStepDetails(executionId, stepId) {
    const execution = this.executions.get(executionId);
    return execution?.steps.get(stepId);
  }
}

export const workflowEngine = new WorkflowEngine();
